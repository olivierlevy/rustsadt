Okay, projet ambitieux et très intéressant ! Mettons en place RustSADT. Nous allons suivre les étapes définies, en commençant par la structure du projet et en développant les composants clés.

**Philosophie:**

- **Simplicité d'abord:** Commençons par un noyau fonctionnel et ajoutons les fonctionnalités progressivement.
- **`egui` pour l'UI:** C'est un excellent choix pour un prototype rapide et multiplateforme en Rust.
- **MVC (adapté à `egui`):** Le `Model` contiendra l'état du diagramme. La `View` sera la fonction `update` de `egui` qui dessine l'état. Le `Controller` sera la logique de gestion des entrées utilisateur dans cette même fonction `update`, modifiant le `Model`.
- **`ron` pour la sérialisation:** C'est lisible et natif à Rust via `serde`.
- **`tera` pour la génération:** Puissant et flexible pour le templating.

---

### 1. Structure du Projet (Arborescence)

```
rustsadt/
├── Cargo.toml
├── src/
│   ├── main.rs             # Point d'entrée, initialisation eframe/egui
│   ├── app.rs              # Structure principale de l'application (Model/View/Controller egui)
│   ├── sadt_model.rs       # Définition des structures du diagramme (ProcessNode, Arrow, Diagram)
│   ├── sadt_elements.rs    # Énumérations et petits types liés au SADT (ArrowType, Side)
│   ├── persistence.rs      # Logique de sauvegarde/chargement (sérialisation RON)
│   ├── generator.rs        # Logique de génération de code Rust et Markdown
│   ├── error.rs            # Type d'erreur personnalisé pour l'application
│   └── ui/
│   │   ├── mod.rs
│   │   ├── drawing.rs        # Fonctions pour dessiner les éléments SADT sur le canvas egui
│   │   └── interaction.rs    # Gestion des interactions utilisateur (drag, select, etc.)
├── templates/              # Templates Tera pour la génération
│   ├── rust_module.tera
│   ├── rust_function.tera
│   └── markdown_doc.tera
└── examples/               # Exemples de diagrammes et de code généré
    ├── simple_process.ron
    └── simple_process_generated.rs
    └── simple_process_doc.md
```

---

### 2. `Cargo.toml`

```toml
[package]
name = "rustsadt"
version = "0.1.0"
edition = "2021"

[dependencies]
eframe = "0.27" # Ou la dernière version stable
egui = { version = "0.27", features = ["persistence"] } # Persistence pour l'état egui si besoin
serde = { version = "1.0", features = ["derive"] }
ron = "0.8"
uuid = { version = "1.8", features = ["v4", "serde"] } # Pour les ID uniques
tera = "1.19"
log = "0.4"
env_logger = "0.11"
rfd = "0.14" # Rust File Dialogs (pour ouvrir/sauvegarder)
thiserror = "1.0" # Pour une gestion d'erreurs facilitée

# Optionnel pour l'export SVG/PNG
# svg = "0.14"
# tiny-skia = "0.11" # Pour rasteriser en PNG (plus complexe)
# usvg = "0.38" # Pour travailler avec SVG
```

---

### 3. Code Source (Squelette et Développement Initial)

#### `src/error.rs`

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum RustSadtError {
    #[error("Erreur d'entrée/sortie: {0}")]
    Io(#[from] std::io::Error),

    #[error("Erreur de sérialisation/désérialisation RON: {0}")]
    Ron(#[from] ron::Error),

    #[error("Erreur de rendu du template Tera: {0}")]
    Tera(#[from] tera::Error),

    #[error("Impossible de trouver le répertoire home")]
    HomeDir,

    #[error("Action annulée par l'utilisateur")]
    UserCancelled,

    #[error("Élément non trouvé avec l'ID: {0}")]
    NotFound(String),

    #[error("Erreur de génération: {0}")]
    Generation(String),

    #[error("Erreur d'interface utilisateur: {0}")]
    Ui(String),
}

pub type Result<T> = std::result::Result<T, RustSadtError>;
```

#### `src/sadt_elements.rs`

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Alias pour clarté
pub type NodeId = Uuid;
pub type ArrowId = Uuid;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ArrowType {
    Input,    // Donnée entrant dans l'activité
    Output,   // Donnée sortant de l'activité
    Control,  // Contrainte ou règle guidant l'activité
    Mechanism, // Ressource utilisée par l'activité (humain, machine)
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    Top,
    Bottom,
    Left,
    Right,
}

// Représente un point de connexion sur un côté d'un nœud
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ConnectionPoint {
    pub node_id: NodeId,
    pub side: Side,
    // Position relative sur le côté (0.0 à 1.0) - Optionnel pour l'instant, on peut connecter au milieu
    // pub relative_pos: f32,
}
```

#### `src/sadt_model.rs`

```rust
use crate::sadt_elements::{ArrowId, ArrowType, ConnectionPoint, NodeId};
use egui::Rect;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessNode {
    pub id: NodeId,
    pub name: String,
    pub rect: Rect, // Position et taille dans l'UI egui
    // On pourrait stocker les IDs des flèches connectées ici, mais
    // il est souvent plus simple de les retrouver via le diagramme global.
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Arrow {
    pub id: ArrowId,
    pub label: Option<String>,
    pub arrow_type: ArrowType,
    pub source: ConnectionPoint,
    pub target: ConnectionPoint,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SadtDiagram {
    pub nodes: HashMap<NodeId, ProcessNode>,
    pub arrows: HashMap<ArrowId, Arrow>,
    // Potentiellement: métadonnées du diagramme (nom, version, etc.)
}

impl SadtDiagram {
    pub fn new() -> Self {
        Default::default()
    }

    pub fn add_node(&mut self, name: String, pos: egui::Pos2) -> NodeId {
        let id = Uuid::new_v4();
        let node = ProcessNode {
            id,
            name,
            rect: Rect::from_min_size(pos, egui::vec2(120.0, 60.0)), // Taille par défaut
        };
        self.nodes.insert(id, node);
        id
    }

    pub fn add_arrow(
        &mut self,
        source: ConnectionPoint,
        target: ConnectionPoint,
        arrow_type: ArrowType,
        label: Option<String>,
    ) -> Option<ArrowId> {
        // Vérifier que les noeuds source et target existent
        if !self.nodes.contains_key(&source.node_id) || !self.nodes.contains_key(&target.node_id) {
           log::warn!("Tentative de création de flèche vers/depuis un noeud inexistant.");
           return None;
        }

        // Vérifier les règles SADT (ex: Input à gauche, Output à droite, etc.)
        // Note: Pour un prototype, on peut être plus flexible initialement.
        match arrow_type {
            ArrowType::Input => if source.side != Side::Left && target.side != Side::Left { /* Pas SADT strict */ },
            ArrowType::Output => if source.side != Side::Right && target.side != Side::Right { /* Pas SADT strict */ },
            ArrowType::Control => if source.side != Side::Top && target.side != Side::Top { /* Pas SADT strict */ },
            ArrowType::Mechanism => if source.side != Side::Bottom && target.side != Side::Bottom { /* Pas SADT strict */ },
        }


        let id = Uuid::new_v4();
        let arrow = Arrow {
            id,
            label,
            arrow_type,
            source,
            target,
        };
        self.arrows.insert(id, arrow);
        Some(id)
    }

    pub fn get_node(&self, id: NodeId) -> Option<&ProcessNode> {
        self.nodes.get(&id)
    }

     pub fn get_node_mut(&mut self, id: NodeId) -> Option<&mut ProcessNode> {
        self.nodes.get_mut(&id)
    }

    pub fn get_arrow(&self, id: ArrowId) -> Option<&Arrow> {
        self.arrows.get(&id)
    }

    pub fn remove_node(&mut self, id: NodeId) -> Option<ProcessNode> {
        // Supprimer aussi les flèches connectées
        self.arrows.retain(|_, arrow| arrow.source.node_id != id && arrow.target.node_id != id);
        self.nodes.remove(&id)
    }

     pub fn remove_arrow(&mut self, id: ArrowId) -> Option<Arrow> {
        self.arrows.remove(&id)
    }
}
```

#### `src/persistence.rs`

```rust
use crate::error::{Result, RustSadtError};
use crate::sadt_model::SadtDiagram;
use rfd::FileDialog;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;

const FILE_EXTENSION: &str = "ron";

// Sauvegarde le diagramme dans un fichier RON
pub fn save_diagram(diagram: &SadtDiagram, path: &PathBuf) -> Result<()> {
    let ron_string = ron::ser::to_string_pretty(diagram, ron::ser::PrettyConfig::default())?;
    let mut file = File::create(path)?;
    file.write_all(ron_string.as_bytes())?;
    log::info!("Diagramme sauvegardé dans: {}", path.display());
    Ok(())
}

// Charge un diagramme depuis un fichier RON
pub fn load_diagram(path: &PathBuf) -> Result<SadtDiagram> {
    let mut file = File::open(path)?;
    let mut ron_string = String::new();
    file.read_to_string(&mut ron_string)?;
    let diagram: SadtDiagram = ron::from_str(&ron_string)?;
     log::info!("Diagramme chargé depuis: {}", path.display());
    Ok(diagram)
}

// Ouvre une boîte de dialogue pour choisir où sauvegarder
pub fn save_diagram_dialog(diagram: &SadtDiagram) -> Result<Option<PathBuf>> {
    let path = FileDialog::new()
        .add_filter("SADT Diagram", &[FILE_EXTENSION])
        .set_file_name("diagram.ron")
        .save_file();

    match path {
        Some(p) => {
            save_diagram(diagram, &p)?;
            Ok(Some(p))
        }
        None => Ok(None), // L'utilisateur a annulé
    }
}

// Ouvre une boîte de dialogue pour choisir quel fichier charger
pub fn load_diagram_dialog() -> Result<Option<(SadtDiagram, PathBuf)>> {
     let path = FileDialog::new()
        .add_filter("SADT Diagram", &[FILE_EXTENSION])
        .pick_file();

     match path {
        Some(p) => {
            let diagram = load_diagram(&p)?;
            Ok(Some((diagram, p)))
        }
        None => Ok(None), // L'utilisateur a annulé
     }
}

```

#### `src/ui/drawing.rs` (Fonctions de dessin simplifiées)

```rust
use crate::sadt_model::{Arrow, ProcessNode, SadtDiagram};
use crate::sadt_elements::{Side, ConnectionPoint};
use egui::{Color32, Painter, Pos2, Rect, Stroke, Vec2};

const NODE_CORNER_RADIUS: f32 = 5.0;
const ARROW_HEAD_SIZE: f32 = 10.0;
const CONNECTION_POINT_RADIUS: f32 = 4.0; // Rayon du petit cercle indiquant où connecter

pub fn draw_diagram(diagram: &SadtDiagram, painter: &Painter, ui_state: &UiState) {
    for node in diagram.nodes.values() {
        draw_node(node, painter, ui_state.selected_node == Some(node.id));
    }
    for arrow in diagram.arrows.values() {
        draw_arrow(arrow, diagram, painter);
    }

    // Dessiner la flèche en cours de création
    if let Some(start_point) = &ui_state.arrow_creation_start {
       if let Some(start_node) = diagram.get_node(start_point.node_id) {
           let start_pos = get_connection_pos(start_node, start_point.side);
           painter.line_segment([start_pos, ui_state.mouse_pos], Stroke::new(1.5, Color32::LIGHT_BLUE));
       }
    }
}

fn draw_node(node: &ProcessNode, painter: &Painter, is_selected: bool) {
    let stroke_color = if is_selected { Color32::YELLOW } else { Color32::GRAY };
    let stroke = Stroke::new(if is_selected { 2.0 } else { 1.0 }, stroke_color);

    painter.rect(
        node.rect,
        NODE_CORNER_RADIUS,
        Color32::from_gray(50), // Couleur de fond
        stroke,
    );

    // Dessiner le nom du noeud centré
    painter.text(
        node.rect.center(),
        egui::Align2::CENTER_CENTER,
        &node.name,
        egui::FontId::proportional(14.0),
        Color32::WHITE,
    );

    // Dessiner les points de connexion (visuels pour l'utilisateur)
    for side in [Side::Left, Side::Right, Side::Top, Side::Bottom] {
        let pos = get_connection_pos(node, side);
        painter.circle_filled(pos, CONNECTION_POINT_RADIUS, Color32::DARK_GRAY);
        painter.circle_stroke(pos, CONNECTION_POINT_RADIUS, Stroke::new(1.0, Color32::GRAY));
    }
}

fn draw_arrow(arrow: &Arrow, diagram: &SadtDiagram, painter: &Painter) {
    if let (Some(source_node), Some(target_node)) = (
        diagram.get_node(arrow.source.node_id),
        diagram.get_node(arrow.target.node_id),
    ) {
        let start_pos = get_connection_pos(source_node, arrow.source.side);
        let end_pos = get_connection_pos(target_node, arrow.target.side);

        let color = match arrow.arrow_type {
            ArrowType::Input => Color32::LIGHT_GREEN,
            ArrowType::Output => Color32::LIGHT_BLUE,
            ArrowType::Control => Color32::LIGHT_RED,
            ArrowType::Mechanism => Color32::LIGHT_YELLOW,
        };
        let stroke = Stroke::new(1.5, color);

        painter.line_segment([start_pos, end_pos], stroke);

        // Dessiner la tête de flèche
        draw_arrow_head(painter, end_pos, start_pos, color);

        // Dessiner le label (simplifié, au milieu)
        if let Some(label) = &arrow.label {
             painter.text(
                start_pos.lerp(end_pos, 0.5), // Position au milieu
                egui::Align2::CENTER_CENTER,
                label,
                egui::FontId::proportional(10.0),
                color,
            );
        }
    } else {
        log::warn!("Impossible de dessiner la flèche {}: noeud source ou cible manquant.", arrow.id);
    }
}

// Calcule la position absolue d'un point de connexion sur un côté
pub fn get_connection_pos(node: &ProcessNode, side: Side) -> Pos2 {
    match side {
        Side::Left => Pos2::new(node.rect.left(), node.rect.center().y),
        Side::Right => Pos2::new(node.rect.right(), node.rect.center().y),
        Side::Top => Pos2::new(node.rect.center().x, node.rect.top()),
        Side::Bottom => Pos2::new(node.rect.center().x, node.rect.bottom()),
    }
}

// Trouve le point de connexion le plus proche d'une position donnée
pub fn find_closest_connection_point(
    diagram: &SadtDiagram,
    pos: Pos2,
    max_dist: f32,
) -> Option<ConnectionPoint> {
    let max_dist_sq = max_dist * max_dist;
    let mut closest_point: Option<ConnectionPoint> = None;
    let mut min_dist_sq = max_dist_sq;

    for node in diagram.nodes.values() {
         for side in [Side::Left, Side::Right, Side::Top, Side::Bottom] {
            let conn_pos = get_connection_pos(node, side);
            let dist_sq = conn_pos.distance_sq(pos);
            if dist_sq < min_dist_sq {
                min_dist_sq = dist_sq;
                closest_point = Some(ConnectionPoint { node_id: node.id, side });
            }
         }
    }
    closest_point
}


fn draw_arrow_head(painter: &Painter, tip: Pos2, origin: Pos2, color: Color32) {
    let dir = (tip - origin).normalized();
    if dir.length_sq() < 0.1 { return; } // Avoid division by zero or NaN

    let normal = Vec2::new(-dir.y, dir.x); // Perpendiculaire

    let p1 = tip - dir * ARROW_HEAD_SIZE;
    let p2 = p1 + normal * ARROW_HEAD_SIZE / 2.0;
    let p3 = p1 - normal * ARROW_HEAD_SIZE / 2.0;

    painter.add(egui::Shape::convex_polygon(
        vec![tip, p2, p3],
        color,
        Stroke::NONE,
    ));
}

// Structure temporaire pour l'état de l'UI (sélection, etc.)
// Sera typiquement dans `app.rs`
#[derive(Debug, Default)]
pub struct UiState {
    pub selected_node: Option<NodeId>,
    pub selected_arrow: Option<ArrowId>,
    pub dragging_node: Option<NodeId>,
    pub arrow_creation_start: Option<ConnectionPoint>, // Point de départ de la flèche en cours
    pub mouse_pos: Pos2, // Dernière position connue de la souris sur le canvas
    pub renaming_node: Option<NodeId>, // ID du noeud en cours de renommage
}

```

#### `src/ui/interaction.rs` (Logique d'interaction basique)

```rust
use crate::app::AppState; // On aura besoin de l'état global
use crate::sadt_elements::{ArrowType, ConnectionPoint, NodeId, Side};
use crate::ui::drawing::{find_closest_connection_point, get_connection_pos, UiState, CONNECTION_POINT_RADIUS};
use egui::{Context, Id, InputState, Key, Order, PointerButton, Pos2, Rect, Sense, Ui};

const DRAG_THRESHOLD: f32 = 5.0; // Distance minimale pour commencer un drag

pub fn handle_canvas_interactions(
    ctx: &Context,
    ui: &mut Ui,
    response: &egui::Response, // Réponse du CentralPanel où l'on dessine
    app_state: &mut AppState, // Accès mutable au modèle et à l'état UI
) {
    app_state.ui_state.mouse_pos = response.hover_pos().unwrap_or_default(); // Mémoriser la position souris

    handle_node_drag_and_select(ctx, response, app_state);
    handle_arrow_creation(ctx, response, app_state);
    handle_node_rename(ctx, response, app_state);
    handle_deletion(ctx, app_state);

    // Clic droit pour le menu contextuel (pas encore implémenté ici)
    response.context_menu(|ui| {
        if app_state.ui_state.selected_node.is_some() {
            if ui.button("Renommer Nœud").clicked() {
                 app_state.ui_state.renaming_node = app_state.ui_state.selected_node;
                 ui.close_menu();
            }
             if ui.button("Supprimer Nœud").clicked() {
                if let Some(id) = app_state.ui_state.selected_node.take() {
                    app_state.diagram.remove_node(id);
                }
                ui.close_menu();
            }
        } else if app_state.ui_state.selected_arrow.is_some() {
             // Ajouter options pour flèches si besoin
        } else {
            if ui.button("Ajouter Nœud").clicked() {
                let pos = response.hover_pos().unwrap_or_else(|| ui.available_rect_before_wrap().min);
                app_state.diagram.add_node("Nouveau Nœud".to_string(), pos);
                 ui.close_menu();
            }
        }
    });
}

fn handle_node_drag_and_select(ctx: &Context, response: &egui::Response, app_state: &mut AppState) {
    let pointer = &ctx.input(|i| i.pointer.clone());

    // Détection début de drag ou sélection
    if response.hovered() && pointer.button_pressed(PointerButton::Primary) {
        let click_pos = pointer.press_origin().unwrap_or_default();
        let mut clicked_on_node = None;

        // Trouver si on a cliqué sur un nœud (ordre inverse du dessin pour le z-index)
        for node in app_state.diagram.nodes.values() {
            if node.rect.contains(click_pos) {
                clicked_on_node = Some(node.id);
                break; // On prend le premier trouvé (le plus "haut")
            }
        }

        if let Some(node_id) = clicked_on_node {
            app_state.ui_state.selected_node = Some(node_id);
            app_state.ui_state.selected_arrow = None;
            // Marquer pour potentiel drag
             ctx.memory_mut(|mem| mem.set_drag_started_by(response.id));

        } else {
             // Clic dans le vide : désélectionner
             app_state.ui_state.selected_node = None;
             app_state.ui_state.selected_arrow = None;
             app_state.ui_state.renaming_node = None; // Arrêter le renommage si on clique ailleurs
        }
    }

    // Gestion du drag en cours
    if pointer.button_down(PointerButton::Primary) && ctx.memory(|mem| mem.is_being_dragged(response.id)) {
       if let Some(node_id) = app_state.ui_state.selected_node {
           if let Some(node) = app_state.diagram.get_node_mut(node_id) {
                node.rect = node.rect.translated(pointer.delta());
           }
           // S'assurer qu'on est bien en mode drag (évite de créer flèche en même temps)
           app_state.ui_state.arrow_creation_start = None;
       }
    }

    // Fin du drag
    if ctx.input(|i| i.pointer.any_released()) {
        ctx.memory_mut(|mem| mem.stop_dragging());
    }
}

fn handle_arrow_creation(ctx: &Context, response: &egui::Response, app_state: &mut AppState) {
    let pointer = &ctx.input(|i| i.pointer.clone());
    let mouse_pos = app_state.ui_state.mouse_pos;

    // Démarrer la création d'une flèche (clic sur un point de connexion)
    if response.hovered() && pointer.button_pressed(PointerButton::Primary) && app_state.ui_state.selected_node.is_none() { // Ne pas démarrer si on sélectionne/drag un noeud
        if let Some(start_point) = find_closest_connection_point(
            &app_state.diagram,
            pointer.press_origin().unwrap_or_default(),
            CONNECTION_POINT_RADIUS * 2.0, // Tolérance autour du point
        ) {
            // Vérifier qu'on ne drag pas déjà un noeud
            if !ctx.memory(|mem| mem.is_anything_being_dragged()) {
                 app_state.ui_state.arrow_creation_start = Some(start_point);
                 // Marquer pour potentiel drag (de la flèche)
                 ctx.memory_mut(|mem| mem.set_drag_started_by(response.id.with("arrow_drag")));
                 log::debug!("Début création flèche depuis: {:?}", start_point);
            }
        }
    }

    // Terminer la création de la flèche (relâchement sur un point de connexion)
    if let Some(start_point) = app_state.ui_state.arrow_creation_start {
        if pointer.any_released() {
             if let Some(end_point) = find_closest_connection_point(
                &app_state.diagram,
                mouse_pos,
                CONNECTION_POINT_RADIUS * 4.0, // Tolérance plus grande au relâchement
            ) {
                if start_point.node_id != end_point.node_id { // Ne pas connecter un noeud à lui-même (simple check)
                    // Déterminer le type de flèche basé sur les côtés (heuristique simple)
                    let arrow_type = match (start_point.side, end_point.side) {
                         (Side::Right, Side::Left) => ArrowType::Output, // ou Input si inversé
                         (Side::Left, Side::Right) => ArrowType::Input,
                         (_, Side::Top) => ArrowType::Control,
                         (_, Side::Bottom) => ArrowType::Mechanism,
                         // Cas par défaut (peut être affiné)
                         (Side::Right, _) => ArrowType::Output,
                         (_, Side::Left) => ArrowType::Input,
                         _ => ArrowType::Input, // Ou un autre défaut
                    };

                    log::debug!("Fin création flèche vers: {:?}, type: {:?}", end_point, arrow_type);
                    app_state.diagram.add_arrow(start_point.clone(), end_point, arrow_type, None);
                } else {
                    log::debug!("Annulation flèche: connexion au même noeud.");
                }
            } else {
                 log::debug!("Annulation flèche: relâchement dans le vide.");
            }
            // Réinitialiser dans tous les cas
            app_state.ui_state.arrow_creation_start = None;
             ctx.memory_mut(|mem| mem.stop_dragging()); // Arrêter le drag spécifique à la flèche
        }
        // Si on relâche sans être sur un point de connexion, la flèche est annulée implicitement par la réinitialisation ci-dessus.
    }
}

fn handle_node_rename(ctx: &Context, response: &egui::Response, app_state: &mut AppState) {
    if let Some(node_id) = app_state.ui_state.renaming_node {
        if let Some(node) = app_state.diagram.get_node(node_id) {
             let mut temp_name = node.name.clone();
             let node_rect = node.rect; // Copier rect avant d'emprunter mut app_state

            // Créer une fenêtre flottante pour l'édition
             egui::Window::new("Renommer Nœud")
                .collapsible(false)
                .resizable(false)
                .title_bar(false)
                .fixed_pos(node_rect.center_top() + egui::vec2(0.0, -30.0)) // Positionner au-dessus du noeud
                .show(ctx, |ui| {
                    let text_edit_response = ui.text_edit_singleline(&mut temp_name);
                    // Mettre le focus la première fois qu'on ouvre la fenêtre
                    if !ctx.memory(|mem| mem.has_focus(text_edit_response.id)) {
                        text_edit_response.request_focus();
                    }
                    // Valider avec Entrée ou perdre le focus
                    if text_edit_response.lost_focus() && ui.input(|i| i.key_pressed(Key::Enter)) {
                        if let Some(node_mut) = app_state.diagram.get_node_mut(node_id) {
                             node_mut.name = temp_name.clone();
                        }
                        app_state.ui_state.renaming_node = None; // Terminer le renommage
                    }
                    // Annuler avec Echap (ou clic extérieur géré par lost_focus sans Enter)
                    if text_edit_response.lost_focus() || ui.input(|i| i.key_pressed(Key::Escape)) {
                        app_state.ui_state.renaming_node = None;
                    }
                });

            // Si la fenêtre d'édition n'est plus ouverte (par ex. clic extérieur), arrêter le renommage
            // Note: egui gère cela implicitement si on utilise `id_source` mais ici on contrôle manuellement
             // On utilise le fait que si on clique ailleurs, le node_id est désélectionné/changé
        } else {
            // Le noeud a été supprimé pendant qu'on le renommait ?
            app_state.ui_state.renaming_node = None;
        }
    } else {
         // Détecter double-clic pour démarrer le renommage
        if response.double_clicked() {
            let click_pos = ctx.input(|i| i.pointer.interact_pos()).unwrap_or_default();
            let mut clicked_on_node = None;
             // Trouver si on a cliqué sur un nœud
            for node in app_state.diagram.nodes.values() {
                if node.rect.contains(click_pos) {
                    clicked_on_node = Some(node.id);
                    break;
                }
            }
             if let Some(node_id) = clicked_on_node {
                app_state.ui_state.renaming_node = Some(node_id);
                app_state.ui_state.selected_node = Some(node_id); // Sélectionner aussi
             }
        }
    }
}

fn handle_deletion(ctx: &Context, app_state: &mut AppState) {
    if ctx.input(|i| i.key_pressed(Key::Delete)) || ctx.input(|i| i.key_pressed(Key::Backspace)) {
        if let Some(node_id) = app_state.ui_state.selected_node.take() {
             log::info!("Suppression noeud: {}", node_id);
            app_state.diagram.remove_node(node_id);
            app_state.ui_state.renaming_node = None; // Assurer qu'on arrête de renommer si supprimé
        } else if let Some(arrow_id) = app_state.ui_state.selected_arrow.take() {
             log::info!("Suppression flèche: {}", arrow_id);
             app_state.diagram.remove_arrow(arrow_id);
        }
    }
}


```

#### `src/generator.rs`

```rust
use crate::error::{Result, RustSadtError};
use crate::sadt_model::{ArrowType, ProcessNode, SadtDiagram};
use serde::Serialize;
use std::collections::HashMap;
use tera::{Context, Tera};

// Structure pour passer les données au template Tera
#[derive(Serialize)]
struct FunctionContext<'a> {
    name: &'a str,
    // Simplifié: on utilise des types génériques ou placeholders
    inputs: Vec<(&'a str, &'a str)>,  // (nom_flèche/placeholder, type_placeholder)
    outputs: Vec<(&'a str, &'a str)>, // (nom_flèche/placeholder, type_placeholder)
    controls: Vec<(&'a str, &'a str)>,
    mechanisms: Vec<(&'a str, &'a str)>,
    // On pourrait ajouter plus d'infos ici (documentation, etc.)
}

#[derive(Serialize)]
struct ModuleContext<'a> {
    module_name: &'a str, // Nom du module (dérivé du diagramme?)
    functions: Vec<FunctionContext<'a>>,
    // Potentiellement: imports nécessaires, structs globales, etc.
}

#[derive(Serialize)]
struct MarkdownContext<'a> {
     nodes: Vec<&'a ProcessNode>,
     // On pourrait ajouter les flèches ici pour une description plus complète
}

pub struct CodeGenerator {
    tera: Tera,
}

impl CodeGenerator {
    pub fn new() -> Result<Self> {
        let mut tera = Tera::new("templates/**/*")?; // Charger tous les templates
        tera.autoescape_on(vec![]); // Important pour générer du code brut
        Ok(CodeGenerator { tera })
    }

    pub fn generate_rust_module(&self, diagram: &SadtDiagram, module_name: &str) -> Result<String> {
        let mut functions_context = Vec::new();

        for node in diagram.nodes.values() {
            let mut inputs = Vec::new();
            let mut outputs = Vec::new();
            let mut controls = Vec::new();
            let mut mechanisms = Vec::new();

            // Trouver les flèches connectées à ce noeud
            for arrow in diagram.arrows.values() {
                let label = arrow.label.as_deref().unwrap_or("data"); // Nom par défaut
                 // Très simplifié: Type placeholder basé sur le type de flèche
                let type_placeholder = match arrow.arrow_type {
                    ArrowType::Input => "InputData",
                    ArrowType::Output => "OutputData",
                    ArrowType::Control => "ControlParam",
                    ArrowType::Mechanism => "MechanismResource",
                };

                if arrow.target.node_id == node.id { // Flèche entrante
                    match arrow.arrow_type {
                        ArrowType::Input => inputs.push((label, type_placeholder)),
                        ArrowType::Control => controls.push((label, type_placeholder)),
                        ArrowType::Mechanism => mechanisms.push((label, type_placeholder)),
                        ArrowType::Output => {} // Une sortie ne devrait pas *entrer* ici
                    }
                } else if arrow.source.node_id == node.id { // Flèche sortante
                     if arrow.arrow_type == ArrowType::Output {
                        outputs.push((label, type_placeholder));
                     }
                }
            }

            functions_context.push(FunctionContext {
                name: &node.name,
                inputs,
                outputs,
                controls,
                mechanisms,
            });
        }

        let context = ModuleContext {
            module_name,
            functions: functions_context,
        };

        let rendered = self
            .tera
            .render("rust_module.tera", &Context::from_serialize(context)?)?;
        Ok(rendered)
    }

     pub fn generate_markdown_doc(&self, diagram: &SadtDiagram) -> Result<String> {
        let nodes: Vec<&ProcessNode> = diagram.nodes.values().collect();
        let context = MarkdownContext { nodes };
        let rendered = self
            .tera
            .render("markdown_doc.tera", &Context::from_serialize(context)?)?;
        Ok(rendered)
     }
}
```

#### `src/app.rs` (Structure principale de l'application)

```rust
use crate::error::Result;
use crate::generator::CodeGenerator;
use crate::persistence::{load_diagram_dialog, save_diagram, save_diagram_dialog};
use crate::sadt_model::SadtDiagram;
use crate::ui::drawing::{draw_diagram, UiState};
use crate::ui::interaction::handle_canvas_interactions;
use eframe::egui;
use egui::{CentralPanel, Frame, Id, LayerId, Order, Pos2, Sense, TopBottomPanel, Vec2};
use std::path::PathBuf;

// État global de l'application
pub struct AppState {
    pub diagram: SadtDiagram,
    pub ui_state: UiState,
    pub current_file_path: Option<PathBuf>,
    pub code_generator: Option<CodeGenerator>, // Initialisé une fois
    pub generated_code: Option<String>,         // Stocker le dernier code généré
    pub generated_doc: Option<String>,          // Stocker la dernière doc générée
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            diagram: SadtDiagram::new(),
            ui_state: UiState::default(),
            current_file_path: None,
            code_generator: CodeGenerator::new().ok(), // Tenter d'initialiser
            generated_code: None,
            generated_doc: None,
        }
    }
}

// Structure principale pour eframe/egui
pub struct RustSadtApp {
    state: AppState,
}

impl Default for RustSadtApp {
    fn default() -> Self {
        Self {
            state: AppState::default(),
        }
    }
}

impl RustSadtApp {
    // Helper pour afficher les erreurs potentielles à l'utilisateur
    fn show_error_popup(&mut self, ctx: &egui::Context, error: &crate::error::RustSadtError) {
        // Pourrait être une fenêtre modale plus élaborée
        egui::Window::new("Erreur")
            .collapsible(false)
            .resizable(false)
            .show(ctx, |ui| {
                ui.label(format!("{}", error));
                if ui.button("Ok").clicked() {
                    // On pourrait fermer la popup ici, mais egui le fait souvent automatiquement
                }
            });
        log::error!("Erreur applicative: {}", error);
    }

    // Fonctions pour gérer les actions du menu
    fn file_new(&mut self) {
        self.state.diagram = SadtDiagram::new();
        self.state.ui_state = UiState::default();
        self.state.current_file_path = None;
        self.state.generated_code = None;
        self.state.generated_doc = None;
         log::info!("Nouveau diagramme créé.");
    }

    fn file_open(&mut self) {
        match load_diagram_dialog() {
            Ok(Some((diagram, path))) => {
                self.state.diagram = diagram;
                self.state.current_file_path = Some(path);
                self.state.ui_state = UiState::default(); // Reset UI state on load
                self.state.generated_code = None; // Clear generated code
                self.state.generated_doc = None;
            }
            Ok(None) => { /* User cancelled */ }
            Err(e) => self.show_error_popup(&egui::Context::default(), &e), // TODO: Pass ctx properly
        }
    }

    fn file_save(&mut self) {
        if let Some(path) = &self.state.current_file_path.clone() { // Clone to avoid borrow issues
            match save_diagram(&self.state.diagram, path) {
                Ok(()) => { /* Success */ }
                Err(e) => self.show_error_popup(&egui::Context::default(), &e), // TODO: Pass ctx properly
            }
        } else {
            self.file_save_as(); // If no path, trigger Save As
        }
    }

     fn file_save_as(&mut self) {
        match save_diagram_dialog(&self.state.diagram) {
            Ok(Some(path)) => {
                self.state.current_file_path = Some(path);
            }
            Ok(None) => { /* User cancelled */ }
             Err(e) => self.show_error_popup(&egui::Context::default(), &e), // TODO: Pass ctx properly
        }
    }

    fn generate_code(&mut self) {
         if let Some(generator) = &self.state.code_generator {
            let module_name = self.state.current_file_path
                .as_ref()
                .and_then(|p| p.file_stem())
                .and_then(|s| s.to_str())
                .unwrap_or("generated_module");

             match generator.generate_rust_module(&self.state.diagram, module_name) {
                Ok(code) => {
                    log::info!("Code Rust généré avec succès.");
                    self.state.generated_code = Some(code);
                    // Optionnel: ouvrir une nouvelle fenêtre pour afficher le code
                }
                Err(e) => self.show_error_popup(&egui::Context::default(), &e), // TODO: Pass ctx properly
            }
         } else {
             log::error!("Générateur de code non initialisé.");
             // Afficher une erreur à l'utilisateur
         }
    }

    fn generate_docs(&mut self) {
         if let Some(generator) = &self.state.code_generator {
             match generator.generate_markdown_doc(&self.state.diagram) {
                Ok(doc) => {
                    log::info!("Documentation Markdown générée avec succès.");
                    self.state.generated_doc = Some(doc);
                    // Optionnel: ouvrir une nouvelle fenêtre pour afficher la doc
                }
                Err(e) => self.show_error_popup(&egui::Context::default(), &e), // TODO: Pass ctx properly
            }
         } else {
             log::error!("Générateur de code non initialisé (requis pour la doc).");
             // Afficher une erreur à l'utilisateur
         }
    }
}

impl eframe::App for RustSadtApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // --- Menu Bar ---
        TopBottomPanel::top("top_panel").show(ctx, |ui| {
            egui::menu::bar(ui, |ui| {
                ui.menu_button("Fichier", |ui| {
                    if ui.button("Nouveau").clicked() {
                        self.file_new();
                        ui.close_menu();
                    }
                    if ui.button("Ouvrir...").clicked() {
                        self.file_open();
                        ui.close_menu();
                    }
                    if ui.button("Sauvegarder").clicked() {
                        self.file_save();
                        ui.close_menu();
                    }
                    if ui.button("Sauvegarder Sous...").clicked() {
                        self.file_save_as();
                        ui.close_menu();
                    }
                    // TODO: Export PNG/SVG
                    ui.separator();
                    if ui.button("Quitter").clicked() {
                        _frame.close();
                    }
                });
                ui.menu_button("Edition", |ui| {
                    if ui.button("Annuler (Undo)").clicked() { /* TODO */ ui.close_menu();}
                    if ui.button("Rétablir (Redo)").clicked() { /* TODO */ ui.close_menu();}
                     ui.separator();
                     if ui.button("Ajouter Nœud").clicked() {
                          // Ajoute au centre de la vue actuelle approx.
                          let pos = Pos2::new(300.0, 200.0); // Placeholder position
                         self.state.diagram.add_node("Nouveau".to_string(), pos);
                         ui.close_menu();
                     }
                });
                 ui.menu_button("Générer", |ui| {
                    if ui.button("Générer Code Rust").clicked() {
                        self.generate_code();
                        ui.close_menu();
                    }
                     if ui.button("Générer Documentation Markdown").clicked() {
                        self.generate_docs();
                        ui.close_menu();
                    }
                });
            });
        });

        // --- Main Canvas ---
        CentralPanel::default()
            .frame(Frame::dark_canvas(&ctx.style())) // Fond sombre pour le canvas
            .show(ctx, |ui| {
                // Utiliser une LayerId dédiée pour le dessin du diagramme
                let canvas_layer_id = LayerId::new(Order::Background, Id::new("sadt_canvas"));
                let painter = ui.painter_at(ui.max_rect()); // Painter pour dessiner sur tout le panel

                // Dessiner le diagramme
                draw_diagram(&self.state.diagram, &painter, &self.state.ui_state);

                // Gérer les interactions sur le canvas après avoir dessiné
                // On prend toute la zone disponible pour les interactions
                let response = ui.allocate_response(ui.available_size(), Sense::click_and_drag());
                handle_canvas_interactions(ctx, ui, &response, &mut self.state);

            });


        // --- Fenêtre Optionnelle pour Code Généré ---
        if let Some(code) = &self.state.generated_code {
             let mut is_open = true; // Pour pouvoir fermer la fenêtre
             egui::Window::new("Code Rust Généré")
                 .open(&mut is_open)
                 .default_width(600.0)
                 .default_height(400.0)
                 .show(ctx, |ui| {
                     egui::ScrollArea::vertical().show(ui, |ui| {
                         // Utiliser un `Label` pour le code permet la sélection,
                         // `code_editor` serait mieux pour de l'édition mais ici on affiche seulement.
                         ui.add(egui::Label::new(code).code());
                     });
                 });
             if !is_open {
                 self.state.generated_code = None; // Fermer la fenêtre en supprimant les données
             }
        }

        // --- Fenêtre Optionnelle pour Doc Générée ---
         if let Some(doc) = &self.state.generated_doc {
             let mut is_open = true;
             egui::Window::new("Documentation Markdown Générée")
                 .open(&mut is_open)
                 .default_width(600.0)
                 .default_height(400.0)
                 .show(ctx, |ui| {
                     egui::ScrollArea::vertical().show(ui, |ui| {
                         // Pour Markdown, on pourrait utiliser une lib de rendu,
                         // mais pour l'instant on affiche le texte brut.
                         ui.add(egui::Label::new(doc).code()); // code() pour police monospace
                     });
                 });
             if !is_open {
                 self.state.generated_doc = None;
             }
         }

         // Afficher les erreurs popup si nécessaire (nécessite une meilleure gestion)
         // Exemple: if let Some(err) = self.state.last_error.take() { self.show_error_popup(ctx, &err); }

        // Demander une mise à jour continue pour les animations ou interactions fluides
        ctx.request_republish();
    }
}
```

#### `src/main.rs`

```rust
use eframe::egui;
mod app;
mod error;
mod generator;
mod persistence;
mod sadt_elements;
mod sadt_model;
mod ui {
    pub mod drawing;
    pub mod interaction;
    pub mod mod_impl { /* Contenu de ui/mod.rs si nécessaire */ }
}


fn main() -> Result<(), eframe::Error> {
    // Setup logging
    env_logger::init(); // Ou un autre logger comme tracing

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1024.0, 768.0])
            .with_min_inner_size([600.0, 400.0]),
            // .with_icon(...) // TODO: Ajouter une icône
        ..Default::default()
    };

    log::info!("Lancement de RustSADT...");

    eframe::run_native(
        "RustSADT", // Titre de la fenêtre
        options,
        Box::new(|_cc| Box::<app::RustSadtApp>::default()), // Créer l'application
    )
}
```

#### `src/ui/mod.rs`

```rust
// Ré-exporter les modules pour un accès plus facile
pub mod drawing;
pub mod interaction;
```

---

### 4. Templates Tera

#### `templates/rust_function.tera` (Inclus dans rust_module.tera)

```rust
/// Generated SADT Function: {{ name }}
///
/// Inputs:{% for input in inputs %}
///   - {{ input.0 }} (Type: {{ input.1 }}){% endfor %}
/// Controls:{% for control in controls %}
///   - {{ control.0 }} (Type: {{ control.1 }}){% endfor %}
/// Mechanisms:{% for mechanism in mechanisms %}
///   - {{ mechanism.0 }} (Type: {{ mechanism.1 }}){% endfor %}
/// Outputs:{% for output in outputs %}
///   - {{ output.0 }} (Type: {{ output.1 }}){% endfor %}
#[allow(unused_variables, unused_mut)] // Pour éviter les warnings sur les placeholders
pub fn {{ name | slugify | lower }}({% for input in inputs %}
    {{ input.0 | slugify | lower }}: {{ input.1 }},{% endfor %}{% for control in controls %}
    {{ control.0 | slugify | lower }}_control: {{ control.1 }},{% endfor %}{% for mechanism in mechanisms %}
    {{ mechanism.0 | slugify | lower }}_resource: &{{ mechanism.1 }},{# Mécanismes souvent passés par référence #}{% endfor %}
) -> ({% for output in outputs %}{{ output.1 }}{% if not loop.last %}, {% endif %}{% else %}(){% endfor %}) {
    // TODO: Implement SADT activity logic for "{{ name }}"
    println!("Executing SADT function: {{ name }}");

    // Placeholder return based on outputs
    {% if outputs %}
    todo!("Return actual output(s)")
    // Exemple: return (Default::default(), ...);
    {% else %}
    // No output defined
    {% endif %}
}

```

#### `templates/rust_module.tera`

```rust
//! Automatically generated Rust module from SADT diagram.
//! Module: {{ module_name }}

// Placeholder types - Define or import actual types as needed.
// Example: type InputData = String;
// type OutputData = i32;
// type ControlParam = bool;
// struct MechanismResource { /* ... */ }
#![allow(dead_code)] // Pour le module généré

{% if functions is containing("InputData") %}type InputData = (); // Placeholder {% endif %}
{% if functions is containing("OutputData") %}type OutputData = (); // Placeholder {% endif %}
{% if functions is containing("ControlParam") %}type ControlParam = (); // Placeholder {% endif %}
{% if functions is containing("MechanismResource") %}struct MechanismResource; // Placeholder {% endif %}


{% for function in functions %}
{{ self::render("rust_function.tera", function) | indent(by=0) }}
{% endfor %}

// --- Main execution flow (optional example) ---
// pub fn run_process() {
//     // Call functions in sequence or based on logic derived from the diagram
//     println!("Running generated SADT process...");
     // Example: let output1 = function_a(input_data);
     // function_b(output1);
// }

```

_Note: La macro `render` n'existe pas nativement dans Tera de cette façon. Il faudrait soit inclure le contenu de `rust_function.tera` ici, soit pré-rendre les fonctions et les injecter comme chaînes._ Pour simplifier ici, imaginons que `rust_function.tera` est inclus ou que le générateur le gère. Une approche plus simple serait de tout mettre dans `rust_module.tera`. Modifions `rust_module.tera` pour inclure directement la logique de la fonction :

#### `templates/rust_module.tera` (Version Intégrée)

```rust
//! Automatically generated Rust module from SADT diagram.
//! Module: {{ module_name }}

// Placeholder types - Define or import actual types as needed.
// Example: type InputData = String;
// type OutputData = i32;
// type ControlParam = bool;
// struct MechanismResource { /* ... */ }
#![allow(dead_code, unused_variables, unused_mut)] // Pour le module généré

type InputData = (); // Placeholder
type OutputData = (); // Placeholder
type ControlParam = (); // Placeholder
struct MechanismResource; // Placeholder

{% for function in functions %}
// --- Function: {{ function.name }} ---

/// Generated SADT Function: {{ function.name }}
///
/// Inputs:{% for input in function.inputs %}
///   - {{ input.0 }} (Type: {{ input.1 }}){% endfor %}
/// Controls:{% for control in function.controls %}
///   - {{ control.0 }} (Type: {{ control.1 }}){% endfor %}
/// Mechanisms:{% for mechanism in function.mechanisms %}
///   - {{ mechanism.0 }} (Type: {{ mechanism.1 }}){% endfor %}
/// Outputs:{% for output in function.outputs %}
///   - {{ output.0 }} (Type: {{ output.1 }}){% endfor %}
pub fn {{ function.name | slugify | lower }}({% for input in function.inputs %}
    {{ input.0 | slugify | lower }}: {{ input.1 }},{% endfor %}{% for control in function.controls %}
    {{ control.0 | slugify | lower }}_control: {{ control.1 }},{% endfor %}{% for mechanism in function.mechanisms %}
    {{ mechanism.0 | slugify | lower }}_resource: &{{ mechanism.1 }},{# Mécanismes souvent passés par référence #}{% endfor %}
) -> ({% for output in function.outputs %}{{ output.1 }}{% if not loop.last %}, {% endif %}{% else %}(){% endfor %}) {
    // TODO: Implement SADT activity logic for "{{ function.name }}"
    println!("Executing SADT function: {{ function.name }}");

    // Placeholder return based on outputs
    {% if function.outputs %}
    todo!("Return actual output(s) for {{ function.name }}")
    // Exemple: return (Default::default(), ...);
    {% else %}
    // No output defined for {{ function.name }}
    {% endif %}
}

{% endfor %}

// --- Main execution flow (optional example) ---
// pub fn run_process() {
//     println!("Running generated SADT process...");
     // Example: let output1 = process_data(...);
     // format_report(output1, ...);
// }
```

#### `templates/markdown_doc.tera`

```markdown
# Documentation SADT Générée

Ce document décrit le diagramme SADT généré par RustSADT.

## Activités (Nœuds)

{% for node in nodes %}

### {{ loop.index }}. {{ node.name }} (ID: `{{ node.id }}`)

- **Description:** (Ajouter une description ici, potentiellement depuis le modèle)
- **Position:** ({{ node.rect.min.x | round }}, {{ node.rect.min.y | round }})
- **Taille:** {{ node.rect.width() | round }} x {{ node.rect.height() | round }}

- **Entrées (Inputs):** (Lister les flèches entrantes de type Input)
- **Sorties (Outputs):** (Lister les flèches sortantes de type Output)
- **Contrôles (Controls):** (Lister les flèches entrantes de type Control)
- **Mécanismes (Mechanisms):** (Lister les flèches entrantes de type Mechanism)

---

{% else %}
Aucun nœud dans ce diagramme.
{% endfor %}

## Flux (Flèches)

(Ajouter une section listant les flèches et leurs connexions si nécessaire)
```

---

### 5. Exemples

#### `examples/simple_process.ron`

```ron
#![enable(implicit_some)]
(
    nodes: {
        // Générer des UUIDs valides ici, ou utiliser des placeholders si uuid non dispo au moment de l'écriture
        "a1a1a1a1-b1b1-c1c1-d1d1-e1e1e1e1e1e1": ProcessNode(
            id: "a1a1a1a1-b1b1-c1c1-d1d1-e1e1e1e1e1e1",
            name: "Traiter Données",
            rect: Rect( min: (100.0, 100.0), max: (220.0, 160.0) ),
        ),
         "a2a2a2a2-b2b2-c2c2-d2d2-e2e2e2e2e2e2": ProcessNode(
            id: "a2a2a2a2-b2b2-c2c2-d2d2-e2e2e2e2e2e2",
            name: "Générer Rapport",
            rect: Rect( min: (300.0, 100.0), max: (420.0, 160.0) ),
        ),
    },
    arrows: {
        "f1f1f1f1-f1f1-f1f1-f1f1-f1f1f1f1f1f1": Arrow(
            id: "f1f1f1f1-f1f1-f1f1-f1f1-f1f1f1f1f1f1",
            label: Some("Données Traitées"),
            arrow_type: Output, // Sortie de "Traiter Données"
            source: ConnectionPoint(
                node_id: "a1a1a1a1-b1b1-c1c1-d1d1-e1e1e1e1e1e1",
                side: Right,
            ),
            target: ConnectionPoint( // Entrée de "Générer Rapport"
                node_id: "a2a2a2a2-b2b2-c2c2-d2d2-e2e2e2e2e2e2",
                side: Left,
            ),
        ),
        // Ajouter d'autres flèches (Input pour 'Traiter Données', Output pour 'Générer Rapport', Controls, Mechanisms...)
         "f2f2f2f2-f2f2-f2f2-f2f2-f2f2f2f2f2f2": Arrow(
            id: "f2f2f2f2-f2f2-f2f2-f2f2-f2f2f2f2f2f2",
            label: Some("Données Brutes"),
            arrow_type: Input,
            source: ConnectionPoint( // Source externe ou noeud précédent (non montré)
                 node_id: "00000000-0000-0000-0000-000000000000", // Placeholder pour externe/non connecté
                 side: Left,
            ),
            target: ConnectionPoint(
                node_id: "a1a1a1a1-b1b1-c1c1-d1d1-e1e1e1e1e1e1",
                side: Left,
            ),
        ),
    },
)
```

_Note: La structure `Rect` de `egui` n'a pas de `Serialize`/`Deserialize` direct. Il faudra soit ajouter une feature `serde` à `egui` si elle existe, soit utiliser une structure intermédiaire sérialisable pour `Rect` (par ex. `[f32; 4]`), soit implémenter `Serialize`/`Deserialize` manuellement pour `ProcessNode`._ Supposons que `egui` avec la feature `persistence` ou `serde` le gère, ou qu'une structure intermédiaire est utilisée.

#### `examples/simple_process_generated.rs` (Basé sur le template et l'exemple RON)

```rust
//! Automatically generated Rust module from SADT diagram.
//! Module: simple_process

// Placeholder types - Define or import actual types as needed.
#![allow(dead_code, unused_variables, unused_mut)] // Pour le module généré

type InputData = (); // Placeholder
type OutputData = (); // Placeholder
type ControlParam = (); // Placeholder
struct MechanismResource; // Placeholder

// --- Function: Traiter Données ---

/// Generated SADT Function: Traiter Données
///
/// Inputs:
///   - donnees_brutes (Type: InputData)
/// Controls:
/// Mechanisms:
/// Outputs:
///   - donnees_traitées (Type: OutputData)
pub fn traiter_donnees(
    donnees_brutes: InputData,
) -> (OutputData) {
    // TODO: Implement SADT activity logic for "Traiter Données"
    println!("Executing SADT function: Traiter Données");

    // Placeholder return based on outputs
    todo!("Return actual output(s) for Traiter Données")
}

// --- Function: Générer Rapport ---

/// Generated SADT Function: Générer Rapport
///
/// Inputs:
///   - donnees_traitées (Type: InputData) // Note: Le type est InputData car c'est une entrée pour CE noeud
/// Controls:
/// Mechanisms:
/// Outputs:
///   - rapport_final (Type: OutputData) // Supposons une flèche de sortie ajoutée
pub fn generer_rapport(
    donnees_traitées: InputData,
) -> (OutputData) {
    // TODO: Implement SADT activity logic for "Générer Rapport"
    println!("Executing SADT function: Générer Rapport");

    // Placeholder return based on outputs
    todo!("Return actual output(s) for Générer Rapport")
}
```

_Correction:_ Le type de `donnees_traitées` pour `generer_rapport` devrait être basé sur le type de la flèche _source_ (Output de `traiter_donnees`), mais dans le template simple actuel, il est déterminé comme `InputData` car c'est une entrée pour `generer_rapport`. Un générateur plus avancé pourrait mieux propager les types.

#### `examples/simple_process_doc.md`

```markdown
# Documentation SADT Générée

Ce document décrit le diagramme SADT généré par RustSADT.

## Activités (Nœuds)

### 1. Traiter Données (ID: `a1a1a1a1-b1b1-c1c1-d1d1-e1e1e1e1e1e1`)

- **Description:** (Ajouter une description ici, potentiellement depuis le modèle)
- **Position:** (100, 100)
- **Taille:** 120 x 60

- **Entrées (Inputs):** Données Brutes (depuis Externe/Placeholder)
- **Sorties (Outputs):** Données Traitées (vers Générer Rapport)
- **Contrôles (Controls):** (Vide)
- **Mécanismes (Mechanisms):** (Vide)

---

### 2. Générer Rapport (ID: `a2a2a2a2-b2b2-c2c2-d2d2-e2e2e2e2e2e2`)

- **Description:** (Ajouter une description ici, potentiellement depuis le modèle)
- **Position:** (300, 100)
- **Taille:** 120 x 60

- **Entrées (Inputs):** Données Traitées (depuis Traiter Données)
- **Sorties (Outputs):** (Vide dans l'exemple .ron, pourrait être 'Rapport Final')
- **Contrôles (Controls):** (Vide)
- **Mécanismes (Mechanisms):** (Vide)

---

## Flux (Flèches)

(Section à remplir manuellement ou par le générateur si amélioré)

- `f1f1f1f1...`: "Données Traitées" (Output) de [Traiter Données] vers [Générer Rapport]
- `f2f2f2f2...`: "Données Brutes" (Input) de [Externe] vers [Traiter Données]
```

---

### 6. Instructions de Compilation et d'Exécution

1.  **Installer Rust:** Si ce n'est pas déjà fait, suivez les instructions sur [rust-lang.org](https://rust-lang.org/).
2.  **Cloner le projet:** (Si le code est dans un dépôt git)
    ```bash
    git clone <url_du_depot>
    cd rustsadt
    ```
3.  **Compiler et Exécuter:**

    ```bash
    cargo run --release
    ```

    L'option `--release` est recommandée pour de meilleures performances de l'interface graphique. La première compilation sera plus longue.

4.  **Utilisation:**
    - Utilisez le menu "Fichier" pour créer, ouvrir ou sauvegarder des diagrammes (`.ron`).
    - Cliquez-droit sur le canvas ou utilisez le menu "Edition" pour ajouter des nœuds.
    - Cliquez sur un nœud pour le sélectionner.
    - Cliquez et glissez un nœud sélectionné pour le déplacer.
    - Double-cliquez sur un nœud pour le renommer (Entrée pour valider, Echap ou clic extérieur pour annuler).
    - Cliquez sur un point de connexion (petit cercle sur le bord d'un nœud) et glissez vers un autre point de connexion pour créer une flèche. Le type de flèche est déterminé automatiquement (simplifié).
    - Appuyez sur `Suppr` ou `Backspace` pour supprimer le nœud ou la flèche sélectionné(e).
    - Utilisez le menu "Générer" pour créer le code Rust ou la documentation Markdown. Les résultats apparaîtront dans de nouvelles fenêtres.

---

Ce prototype fournit une base solide pour RustSADT. Les prochaines étapes pourraient inclure:

- Amélioration du dessin (flèches courbes, meilleur placement des labels).
- Gestion d'état plus robuste (Undo/Redo).
- Personnalisation des types de données dans l'UI pour la génération de code.
- Implémentation de l'export SVG/PNG.
- Validation plus stricte des règles SADT.
- Amélioration de la gestion des erreurs et des retours utilisateur.
- Support i18n.
- Tests unitaires et d'intégration.
